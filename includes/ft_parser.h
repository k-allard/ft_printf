/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_parser.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kallard <kallard@student.21-school.ru>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/11 11:05:00 by kallard           #+#    #+#             */
/*   Updated: 2020/07/11 11:11:18 by kallard          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FT_PARSER_H
# define FT_PARSER_H

# include <stdarg.h>
# include <unistd.h>

typedef enum		e_type
{
	d		= 'd',	//d, i — десятичное знаковое число, размер по умолчанию, sizeof( int ). По умолчанию записывается с правым выравниванием, знак пишется только для отрицательных чисел. '%d' и '%i' ведут себя одинаково при выводе, но имеют разные значения при вводе с помощью функции scanf();
	i		= 'i',	//d, i — десятичное знаковое число, размер по умолчанию, sizeof( int ). По умолчанию записывается с правым выравниванием, знак пишется только для отрицательных чисел. '%d' и '%i' ведут себя одинаково при выводе, но имеют разные значения при вводе с помощью функции scanf();
	o		= 'o',	//o — восьмеричное беззнаковое число, размер по умолчанию sizeof( int );
	u		= 'u',	//u — десятичное беззнаковое число, размер по умолчанию sizeof( int );
	x		= 'x',	//x и X — шестнадцатеричное беззнаковое число, x использует маленькие буквы (abcdef), X большие (ABCDEF), размер по умолчанию sizeof( int );
	X 		= 'X',	//x и X — шестнадцатеричное беззнаковое число, x использует маленькие буквы (abcdef), X большие (ABCDEF), размер по умолчанию sizeof( int );
	f       = 'f',	//f и F — числа с плавающей запятой. По умолчанию выводятся с точностью 6, если число по модулю меньше единицы, перед десятичной точкой пишется 0. Величины ±∞ представляются в форме [-]inf или [-]infinity, Величина Nan представляется как [-]nan или [-]nan(любой текст далее). Использование F выводит указанные величины заглавными буквами (-INF, NAN). Аргумент по умолчанию имеет размер double.
	F       = 'F',	//f и F — числа с плавающей запятой. По умолчанию выводятся с точностью 6, если число по модулю меньше единицы, перед десятичной точкой пишется 0. Величины ±∞ представляются в форме [-]inf или [-]infinity, Величина Nan представляется как [-]nan или [-]nan(любой текст далее). Использование F выводит указанные величины заглавными буквами (-INF, NAN). Аргумент по умолчанию имеет размер double.
	e       = 'e',	//e и E — числа с плавающей запятой в экспоненциальной форме записи (вида 1.1e+44); e выводит символ «e» в нижнем регистре, E — в верхнем (3.14E+0);
	E       = 'E',	//e и E — числа с плавающей запятой в экспоненциальной форме записи (вида 1.1e+44); e выводит символ «e» в нижнем регистре, E — в верхнем (3.14E+0);
	g       = 'g',	//g и G — число с плавающей запятой; форма представления зависит от значения величины (f или e). Формат немного отличается от числа с плавающей запятой тем, что незначащие нули справа от запятой не выводятся. Также часть с запятой не отображается, если число целое;
	G       = 'G',	//g и G — число с плавающей запятой; форма представления зависит от значения величины (f или e). Формат немного отличается от числа с плавающей запятой тем, что незначащие нули справа от запятой не выводятся. Также часть с запятой не отображается, если число целое;
	a       = 'a',	//a и A — число с плавающей запятой в шестнадцатеричном виде;
	A       = 'A',	//a и A — число с плавающей запятой в шестнадцатеричном виде;
	c       = 'c',	//c — вывод символа с кодом, соответствующим переданному аргументу; переданное число приводится к типу unsigned char (или wchar t, если был указан модификатор длины l);
	s       = 's',	//s — вывод строки с нулевым завершающим байтом; если модификатор длины — l, выводится строка wchar_t*. В Windows значения типа s зависят от типа используемых функций. Если используется семейство printf функций, то s обозначает строку char*. Если используется семейство wprintf функций, то s обозначает строку wchar_t*.
	S       = 'S',	//S — то же самое, что и s с модификатором длины l; В Windows значения типа S зависит от типа используемых функций. Если используется семейство printf функций, то S обозначает строку wchar_t*. Если используется семейство wprintf функций, то S обозначает строку char*.
	p       = 'p',	//p — вывод указателя, внешний вид может существенно различаться в зависимости от внутреннего представления в компиляторе и платформе (например, 16-битная платформа MS-DOS использует форму записи вида FFEC:1003, 32-битная платформа с плоской адресацией использует адрес вида 00FA0030);
	n       = 'n',	//n — запись по указателю, переданному в качестве аргумента, количества символов, записанных на момент появления командной последовательности, содержащей n;
	percent = '%'	//% — символ для вывода знака процента (%), используется для возможности вывода символов процента в строке printf, всегда используется в виде %%.
}				t_type;


typedef struct	s_flags
{
	int 		minus;	//[-] выводимое значение выравнивается по левому краю в пределах минимальной ширины поля 
	int 		plus;	//[+] всегда указывать знак (плюс или минус) для выводимого десятичного числового значения 
	int 		space;	//[ ]  помещать перед результатом пробел, если первый символ значения не знак 
	int 		zero;	//[0] дополнять поле до ширины, указанной в поле [ширина] управляющей последовательности, символом 0
	int 		hash;	//[#] «альтернативная форма» вывода значения 
} 				t_flags;

typedef	enum	e_ok
{
	OK,
	ERROR
}				t_ok;

typedef	struct	s_format
{
	t_flags		flags;
	int			width;
	int			precision;
	int			length;
	t_type		type;
	t_ok		ok;
}				t_format;

void		ft_flags_parse(const char* format, int*	i, t_format* argformat);
void		ft_modifier_parse(const char* format, int*	i, t_format* argformat);
t_format	ft_parser(va_list* argptr, const char* format, int*	i);
void		ft_precision_parse(va_list* argptr, const char* format, int*	i, t_format* argformat);
void		ft_width_parse(va_list* argptr, const char* format, int*	i, t_format* argformat);

#endif